
==================== FINAL INTERFACE ====================
2016-11-14 17:15:03.5229548 UTC

interface DN-0.1.0.0-8yMn8QkkcEWDg7GIz2sx1m:Lib 8001
  interface hash: 03176242d714e5bb8d67ce9a1d832df9
  ABI hash: fdfdaa603c1449dfab0256e12471a0df
  export-list hash: 36dcec8a9c4309ff73265a1f74e4e6f7
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: edcd53bcabe721b232ec99aa727489bd
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.bottumUpResponse
  Lib.c
  Lib.dot
  Lib.gamma
  Lib.hebbianLearn
  Lib.hebbianLearnHidden
  Lib.hebbianLearnMotor
  Lib.hiddenResponse
  Lib.hiddenTopK
  Lib.initialNetwork
  Lib.k
  Lib.lRate
  Lib.motorResponse
  Lib.normalize
  Lib.runNetwork
  Lib.runNetwork'
  Lib.t1
  Lib.t2
  Lib.topDownResponse
  Lib.topK
  Lib.updateHiddenWeights
  Lib.updateMotorWeights
  Lib.HiddenLayer{Lib.HiddenLayer}
  Lib.MotorLayer{Lib.MotorLayer}
  Lib.Network{Lib.Network}
  Lib.Neuron{Lib.Neuron age weights}
  Lib.Neuron2{Lib.Neuron2 age2 bottomUpWeights topDownWeights}
  Lib.Response
  Lib.SensorLayer{Lib.SensorLayer}
module dependencies:
package dependencies: base-4.9.0.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.OldList 3c899c6d8e6204063769214449ac0954
import  -/  base-4.9.0.0:Data.Ord f0d073170d91d9483c5cc4a834e93dcf
import  -/  base-4.9.0.0:Debug.Trace 20d3743adf2ab5800d4c01c8ae9f5b53
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $fShowHiddenLayer :: GHC.Show.Show Lib.HiddenLayer
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.HiddenLayer
                  Lib.$fShowHiddenLayer_$cshowsPrec
                  Lib.$fShowHiddenLayer_$cshow
                  Lib.$fShowHiddenLayer_$cshowList -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $fShowHiddenLayer1 :: Lib.HiddenLayer -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.HiddenLayer) (w1 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec 0# w w1) -}
475dec75939be41030091126e6d13919
  $fShowHiddenLayer2 :: Lib.Neuron2 -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.Neuron2) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Neuron2 ww1 ww2 ww3 ->
                 Lib.$w$cshowsPrec1 0# ww1 ww2 ww3 w1 }) -}
b1c340be628efafc385f7740d9c9544b
  $fShowHiddenLayer3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HiddenLayer "#) -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $fShowHiddenLayer_$cshow :: Lib.HiddenLayer -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.HiddenLayer) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c1 n Lib.$fShowHiddenLayer3)
                   (GHC.Show.showList__
                      @ Lib.Neuron2
                      Lib.$fShowHiddenLayer2
                      x3 `cast` (Lib.N:HiddenLayer[0])
                      (GHC.Types.[] @ GHC.Types.Char))) -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $fShowHiddenLayer_$cshowList :: [Lib.HiddenLayer] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.HiddenLayer
                   Lib.$fShowHiddenLayer1) -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $fShowHiddenLayer_$cshowsPrec ::
    GHC.Types.Int -> Lib.HiddenLayer -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.HiddenLayer)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec ww1 w1 w2 }) -}
da4286604bced03d08ca13e3c3563f72
  $fShowMotorLayer :: GHC.Show.Show Lib.MotorLayer
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.MotorLayer
                  Lib.$fShowMotorLayer_$cshowsPrec
                  Lib.$fShowMotorLayer_$cshow
                  Lib.$fShowMotorLayer_$cshowList -}
da4286604bced03d08ca13e3c3563f72
  $fShowMotorLayer1 :: Lib.MotorLayer -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.MotorLayer) (w1 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec2 0# w w1) -}
deb5b4ea1a9c95b14b5ef489ae53e174
  $fShowMotorLayer2 :: Lib.Neuron -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.Neuron) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Neuron ww1 ww2 ->
                 Lib.$w$cshowsPrec3 0# ww1 ww2 w1 }) -}
d4581f515ffa26a3661dc9027ee19465
  $fShowMotorLayer3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Neuron {"#) -}
cbb2df2e11d771bb18285a869cd44956
  $fShowMotorLayer4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
6be7edc4b3b0cb5075a6ed5dddedb2e5
  $fShowMotorLayer5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "age = "#) -}
97e6afe85f8ddf31539284f054b6a93e
  $fShowMotorLayer6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
18505288bb0d8be1e27913854a9d54b3
  $fShowMotorLayer7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "weights = "#) -}
035e66b5e117ec68d8b7117531d7ddce
  $fShowMotorLayer8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MotorLayer "#) -}
da4286604bced03d08ca13e3c3563f72
  $fShowMotorLayer_$cshow :: Lib.MotorLayer -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.MotorLayer) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c1 n Lib.$fShowMotorLayer8)
                   (GHC.Show.showList__
                      @ Lib.Neuron
                      Lib.$fShowMotorLayer2
                      x3 `cast` (Lib.N:MotorLayer[0])
                      (GHC.Types.[] @ GHC.Types.Char))) -}
da4286604bced03d08ca13e3c3563f72
  $fShowMotorLayer_$cshowList :: [Lib.MotorLayer] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.MotorLayer
                   Lib.$fShowMotorLayer1) -}
da4286604bced03d08ca13e3c3563f72
  $fShowMotorLayer_$cshowsPrec ::
    GHC.Types.Int -> Lib.MotorLayer -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.MotorLayer)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec2 ww1 w1 w2 }) -}
6454729dbbe9bad18df56f70ee83423b
  $fShowNetwork :: GHC.Show.Show Lib.Network
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Network
                  Lib.$fShowNetwork_$cshowsPrec
                  Lib.$fShowNetwork_$cshow
                  Lib.$fShowNetwork_$cshowList -}
6454729dbbe9bad18df56f70ee83423b
  $fShowNetwork1 :: Lib.Network -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.Network) (w1 :: GHC.Base.String) ->
                 case w of ww { Lib.Network ww1 ww2 ->
                 Lib.$w$cshowsPrec4 0# ww1 ww2 w1 }) -}
3363d734273e1108573310f64132b38f
  $fShowNetwork2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Network "#) -}
6454729dbbe9bad18df56f70ee83423b
  $fShowNetwork_$cshow :: Lib.Network -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.Network) ->
                 Lib.$fShowNetwork_$cshowsPrec
                   GHC.Show.shows22
                   x3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6454729dbbe9bad18df56f70ee83423b
  $fShowNetwork_$cshowList :: [Lib.Network] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Network
                   Lib.$fShowNetwork1) -}
6454729dbbe9bad18df56f70ee83423b
  $fShowNetwork_$cshowsPrec ::
    GHC.Types.Int -> Lib.Network -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Network)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Network ww3 ww4 ->
                 Lib.$w$cshowsPrec4 ww1 ww3 ww4 w2 } }) -}
deb5b4ea1a9c95b14b5ef489ae53e174
  $fShowNeuron :: GHC.Show.Show Lib.Neuron
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Neuron
                  Lib.$fShowNeuron_$cshowsPrec
                  Lib.$fShowNeuron_$cshow
                  Lib.$fShowNeuron_$cshowList -}
475dec75939be41030091126e6d13919
  $fShowNeuron2 :: GHC.Show.Show Lib.Neuron2
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.Neuron2
                  Lib.$fShowNeuron2_$cshowsPrec
                  Lib.$fShowNeuron2_$cshow
                  Lib.$fShowNeuron2_$cshowList -}
475dec75939be41030091126e6d13919
  $fShowNeuron2_$cshow :: Lib.Neuron2 -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.Neuron2) ->
                 Lib.$fShowNeuron2_$cshowsPrec
                   GHC.Show.shows22
                   x3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
475dec75939be41030091126e6d13919
  $fShowNeuron2_$cshowList :: [Lib.Neuron2] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Neuron2
                   Lib.$fShowHiddenLayer2) -}
475dec75939be41030091126e6d13919
  $fShowNeuron2_$cshowsPrec ::
    GHC.Types.Int -> Lib.Neuron2 -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Neuron2)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Neuron2 ww3 ww4 ww5 ->
                 Lib.$w$cshowsPrec1 ww1 ww3 ww4 ww5 w2 } }) -}
deb5b4ea1a9c95b14b5ef489ae53e174
  $fShowNeuron_$cshow :: Lib.Neuron -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.Neuron) ->
                 Lib.$fShowNeuron_$cshowsPrec
                   GHC.Show.shows22
                   x3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
deb5b4ea1a9c95b14b5ef489ae53e174
  $fShowNeuron_$cshowList :: [Lib.Neuron] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.Neuron
                   Lib.$fShowMotorLayer2) -}
deb5b4ea1a9c95b14b5ef489ae53e174
  $fShowNeuron_$cshowsPrec ::
    GHC.Types.Int -> Lib.Neuron -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.Neuron)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lib.Neuron ww3 ww4 ->
                 Lib.$w$cshowsPrec3 ww1 ww3 ww4 w2 } }) -}
5b1a51a62a0a167a031b4d504bd0330a
  $fShowSensorLayer :: GHC.Show.Show Lib.SensorLayer
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lib.SensorLayer
                  Lib.$fShowSensorLayer_$cshowsPrec
                  Lib.$fShowSensorLayer_$cshow
                  Lib.$fShowSensorLayer_$cshowList -}
5b1a51a62a0a167a031b4d504bd0330a
  $fShowSensorLayer1 :: Lib.SensorLayer -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Lib.SensorLayer) (w1 :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec5 0# w w1) -}
896dae3dcc3cfc8047017107c23b2d00
  $fShowSensorLayer2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SensorLayer "#) -}
5b1a51a62a0a167a031b4d504bd0330a
  $fShowSensorLayer_$cshow :: Lib.SensorLayer -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x3 :: Lib.SensorLayer) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c1 n Lib.$fShowSensorLayer2)
                   (GHC.Show.showList__
                      @ GHC.Types.Double
                      GHC.Float.$fShowDouble1
                      x3 `cast` (Lib.N:SensorLayer[0])
                      (GHC.Types.[] @ GHC.Types.Char))) -}
5b1a51a62a0a167a031b4d504bd0330a
  $fShowSensorLayer_$cshowList :: [Lib.SensorLayer] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lib.SensorLayer
                   Lib.$fShowSensorLayer1) -}
5b1a51a62a0a167a031b4d504bd0330a
  $fShowSensorLayer_$cshowsPrec ::
    GHC.Types.Int -> Lib.SensorLayer -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Lib.SensorLayer)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lib.$w$cshowsPrec5 ww1 w1 w2 }) -}
b86967c6dd1888eead1ae6c6e9bbb4f5
  $tc'HiddenLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8302863829632451421##
                   7035908270735615647##
                   Lib.$trModule
                   Lib.$tc'HiddenLayer1) -}
fee460277b6eff7a1efd081f46fcadbe
  $tc'HiddenLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HiddenLayer"#) -}
54d90574497b59353c9fc94e48ee3aa1
  $tc'MotorLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4849039749569772701##
                   4337142762608626401##
                   Lib.$trModule
                   Lib.$tc'MotorLayer1) -}
bc9871ce72b4890cae1241467a00e890
  $tc'MotorLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MotorLayer"#) -}
ff5ee2fedcecbd737d00d1157c248e60
  $tc'Network :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12741241070967766265##
                   283234596555989579##
                   Lib.$trModule
                   Lib.$tc'Network1) -}
0aad2c1c0309a32464c970407678a235
  $tc'Network1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Network"#) -}
854641cbded8c6dff0dc735701252052
  $tc'Neuron :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8402374203720580315##
                   1701140850482707248##
                   Lib.$trModule
                   Lib.$tc'Neuron1) -}
2b32f56a793e065e599afa5e5054478b
  $tc'Neuron1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Neuron"#) -}
74eda583930ee8ab1adf11d833018e39
  $tc'Neuron2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1719781723041640179##
                   669237472921793990##
                   Lib.$trModule
                   Lib.$tc'Neuron3) -}
7e5c2ff580436352c0974c87c527e2f1
  $tc'Neuron3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Neuron2"#) -}
d5eb621b547834d832b67654dad010bb
  $tc'SensorLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17072361240257852204##
                   8693387044562408139##
                   Lib.$trModule
                   Lib.$tc'SensorLayer1) -}
44622a8ac3356e10c76ba8d9e3bb1b2a
  $tc'SensorLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SensorLayer"#) -}
e7ca81c8b0ed0268325c8221b5bb07f8
  $tcHiddenLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14697940137947029859##
                   18145538216938186301##
                   Lib.$trModule
                   Lib.$tcHiddenLayer1) -}
7d4c2b7ad3a8f8d7438091872fa2feb9
  $tcHiddenLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HiddenLayer"#) -}
f6c38dbe594b22a60cdf2561b9640779
  $tcMotorLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11475729911707971818##
                   9110696200767233253##
                   Lib.$trModule
                   Lib.$tcMotorLayer1) -}
66f49d11826b55872d38dce930fcd544
  $tcMotorLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "MotorLayer"#) -}
5c9bc034014157b93a10ca84a7108722
  $tcNetwork :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6857604494273160367##
                   13779790193292079916##
                   Lib.$trModule
                   Lib.$tcNetwork1) -}
76cafe74f56e8726d8a6f09ef8dbcc63
  $tcNetwork1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Network"#) -}
ec59aeb20847c292d7b2cabcc0441799
  $tcNeuron :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8004393656819181147##
                   12713173677252173803##
                   Lib.$trModule
                   Lib.$tcNeuron1) -}
2147af9e2784905aa90129abfb188dc8
  $tcNeuron1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Neuron"#) -}
42c6e8ded2575c717537699a53fedd71
  $tcNeuron2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8245788511596887265##
                   1347225349218594366##
                   Lib.$trModule
                   Lib.$tcNeuron3) -}
63dafaf27b3a1710dfb2502345e81fe9
  $tcNeuron3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Neuron2"#) -}
ead088bfbb690d24d163d2e2f7cc549c
  $tcSensorLayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4709955997440520173##
                   5431313412565524176##
                   Lib.$trModule
                   Lib.$tcSensorLayer1) -}
6ab0dc9ff27580a16f71def1cdad65a1
  $tcSensorLayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SensorLayer"#) -}
0a1515275c12c01c5369c97d150cc8c2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
c702d7a69e7df65e5c9f3390d8d1a80b
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
abb685e2f6c0a4b57f93bf7b799bbe81
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "DN-0.1.0.0-8yMn8QkkcEWDg7GIz2sx1m"#) -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Lib.HiddenLayer -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Lib.HiddenLayer)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowHiddenLayer3
                        (GHC.Show.showList__
                           @ Lib.Neuron2
                           Lib.$fShowHiddenLayer2
                           w `cast` (Lib.N:HiddenLayer[0])
                           w1)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowHiddenLayer3
                           (GHC.Show.showList__
                              @ Lib.Neuron2
                              Lib.$fShowHiddenLayer2
                              w `cast` (Lib.N:HiddenLayer[0])
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1))) }) -}
dd2efe9cbe51e008fdbb3983a7b56070
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <S,U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [0] -}
da4286604bced03d08ca13e3c3563f72
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Lib.MotorLayer -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Lib.MotorLayer)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowMotorLayer8
                        (GHC.Show.showList__
                           @ Lib.Neuron
                           Lib.$fShowMotorLayer2
                           w `cast` (Lib.N:MotorLayer[0])
                           w1)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowMotorLayer8
                           (GHC.Show.showList__
                              @ Lib.Neuron
                              Lib.$fShowMotorLayer2
                              w `cast` (Lib.N:MotorLayer[0])
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1))) }) -}
beb31bef307e114cec9923c5ae3c9c3b
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> [GHC.Types.Double]
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [GHC.Types.Double])
                   (ww2 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x3 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowMotorLayer7
                       (let {
                          s :: GHC.Base.String
                          = GHC.Base.++
                              @ GHC.Types.Char
                              Lib.$fShowMotorLayer6
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 Lib.$fShowMotorLayer5
                                 (case ww2 of ww3 { GHC.Types.I# ww4 ->
                                  case GHC.Show.$wshowSignedInt
                                         0#
                                         ww4
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            Lib.$fShowMotorLayer4
                                            x3) of ww5 { (#,#) ww6 ww7 ->
                                  GHC.Types.: @ GHC.Types.Char ww6 ww7 } }))
                        } in
                        case ww1 of wild {
                          [] -> GHC.CString.unpackAppendCString# "[]"# s
                          : x4 xs
                          -> GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showList__2
                               (case x4 of ww3 { GHC.Types.D# ww4 ->
                                GHC.Float.$w$sshowSignedFloat
                                  GHC.Float.$fShowDouble_$sshowFloat
                                  GHC.Float.minExpt
                                  ww4
                                  (let {
                                     lvl27 :: [GHC.Types.Char]
                                     = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__1 s
                                   } in
                                   letrec {
                                     showl :: [GHC.Types.Double] -> GHC.Base.String
                                       {- Arity: 1, Strictness: <S,1*U> -}
                                     = \ (ds2 :: [GHC.Types.Double]) ->
                                       case ds2 of wild1 {
                                         [] -> lvl27
                                         : y ys
                                         -> GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows7
                                              (case y of ww5 { GHC.Types.D# ww6 ->
                                               GHC.Float.$w$sshowSignedFloat
                                                 GHC.Float.$fShowDouble_$sshowFloat
                                                 GHC.Float.minExpt
                                                 ww6
                                                 (showl ys) }) }
                                   } in
                                   showl xs) }) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Lib.$fShowMotorLayer3 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowMotorLayer3
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w))) }) -}
cd30be2644b2000e4ef9d8b7c822e076
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Lib.HiddenLayer
    -> Lib.MotorLayer
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Lib.HiddenLayer)
                   (ww2 :: Lib.MotorLayer)
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x3 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lib.$fShowNetwork2
                       (Lib.$w$cshowsPrec
                          11#
                          ww1
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (Lib.$w$cshowsPrec2 11# ww2 x3)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w)) }) -}
5b1a51a62a0a167a031b4d504bd0330a
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> Lib.SensorLayer -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Lib.SensorLayer)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lib.$fShowSensorLayer2
                        (GHC.Show.showList__
                           @ GHC.Types.Double
                           GHC.Float.$fShowDouble1
                           w `cast` (Lib.N:SensorLayer[0])
                           w1)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lib.$fShowSensorLayer2
                           (GHC.Show.showList__
                              @ GHC.Types.Double
                              GHC.Float.$fShowDouble1
                              w `cast` (Lib.N:SensorLayer[0])
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1))) }) -}
72c3ddf3e7cde7e96339969013859c05
  $wgo ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U>,
     Inline: [0] -}
f05db5f9c892e70e1327551633767749
  $wgo1 ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]]
    -> Lib.HiddenLayer
    -> Lib.MotorLayer
    -> (# Lib.HiddenLayer, Lib.MotorLayer #)
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,U><L,U>, Inline: [0] -}
9d0e10e22746234de3feb54e956abba4
  $whebbianLearn ::
    [GHC.Types.Double]
    -> GHC.Types.Int -> Lib.Response -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Double])
                   (ww1 :: GHC.Types.Int)
                   (w :: Lib.Response) ->
                 let {
                   learningRate :: GHC.Types.Double
                   = case ww1 of wild { GHC.Types.I# x3 ->
                     case GHC.Prim./##
                            1.0##
                            (GHC.Prim.int2Double# (GHC.Prim.+# x3 1#)) of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } }
                 } in
                 GHC.List.zipWith
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   (\ (w1 :: GHC.Types.Double) (y' :: GHC.Types.Double)[OneShot] ->
                    case learningRate of wild1 { GHC.Types.D# y ->
                    case w1 of wild2 { GHC.Types.D# y1 ->
                    case y' of wild3 { GHC.Types.D# y2 ->
                    GHC.Types.D#
                      (GHC.Prim.+##
                         (GHC.Prim.*## (GHC.Prim.-## 1.0## y) y1)
                         (GHC.Prim.*## y y2)) } } })
                   ww
                   w) -}
1260124d33c37ffab7857b7855590a6b
  $whebbianLearnMotor ::
    [GHC.Types.Double]
    -> GHC.Types.Int -> Lib.Response -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Double])
                   (ww1 :: GHC.Types.Int)
                   (w :: Lib.Response) ->
                 let {
                   learningRate :: GHC.Types.Double
                   = case ww1 of wild { GHC.Types.I# x3 ->
                     case GHC.Prim./##
                            1.0##
                            (GHC.Prim.int2Double# (GHC.Prim.+# x3 1#)) of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } }
                 } in
                 GHC.List.zipWith
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   (\ (w1 :: GHC.Types.Double) (y' :: GHC.Types.Double)[OneShot] ->
                    case learningRate of wild1 { GHC.Types.D# y ->
                    case w1 of wild2 { GHC.Types.D# y1 ->
                    case y' of wild3 { GHC.Types.D# y2 ->
                    GHC.Types.D#
                      (GHC.Prim.+##
                         (GHC.Prim.*## (GHC.Prim.-## 1.0## y) y1)
                         (GHC.Prim.*## y y2)) } } })
                   ww
                   w) -}
5f62f4701238d3efccddc8ad2fe3cdab
  $wrunNetwork ::
    [[GHC.Types.Double]]
    -> [[GHC.Types.Double]] -> (# Lib.HiddenLayer, Lib.MotorLayer #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [[GHC.Types.Double]])
                   (w1 :: [[GHC.Types.Double]]) ->
                 case w of wild {
                   []
                   -> case Lib.runNetwork5
                      ret_ty (# Lib.HiddenLayer, Lib.MotorLayer #)
                      of {}
                   : z zs
                   -> case w1 of wild1 {
                        []
                        -> case Lib.runNetwork5
                           ret_ty (# Lib.HiddenLayer, Lib.MotorLayer #)
                           of {}
                        : x3 xs
                        -> let {
                             newHiddenLayer :: Lib.HiddenLayer
                             = Lib.hebbianLearnHidden
                                 x3
                                 (Lib.hiddenResponse
                                    z
                                    x3
                                    Lib.initialNetwork2 `cast` (Sym (Lib.N:HiddenLayer[0])))
                                 z
                                 Lib.initialNetwork2 `cast` (Sym (Lib.N:HiddenLayer[0]))
                           } in
                           case Debug.Trace.trace
                                  @ (Lib.HiddenLayer -> Lib.MotorLayer -> Lib.Network)
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows9
                                     (Lib.$w$cshowsPrec 0# newHiddenLayer Lib.runNetwork1))
                                  Lib.Network
                                  newHiddenLayer
                                  Lib.initialNetwork1
                                    `cast`
                                  (Sym (Lib.N:MotorLayer[0])) of ww { Lib.Network ww1 ww2 ->
                           Lib.$wgo1 zs xs ww1 ww2 } } }) -}
472d6ef5a9b8137937efcf4033c25c85
  $wrunNetwork' ::
    Lib.HiddenLayer
    -> Lib.MotorLayer -> Lib.Response -> Lib.Response -> Lib.Network
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lib.HiddenLayer)
                   (ww1 :: Lib.MotorLayer)
                   (ww2 :: Lib.Response)
                   (ww3 :: Lib.Response) ->
                 let {
                   newHiddenResponse :: Lib.Response = Lib.hiddenResponse ww2 ww3 ww
                 } in
                 let {
                   newHiddenLayer :: Lib.HiddenLayer
                   = Lib.hebbianLearnHidden ww3 newHiddenResponse ww2 ww
                 } in
                 let {
                   newMotorLayer :: [Lib.Neuron]
                   = Lib.runNetwork'1 ww2 newHiddenResponse ww1
                 } in
                 Debug.Trace.trace
                   @ (Lib.HiddenLayer -> Lib.MotorLayer -> Lib.Network)
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows9
                      (Lib.$w$cshowsPrec
                         0#
                         newHiddenLayer
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows7
                            (GHC.Show.$fShow(,)_$sgo
                               Lib.runNetwork4
                               (\ (w :: GHC.Base.String) ->
                                Lib.$w$cshowsPrec2
                                  0#
                                  newMotorLayer `cast` (Sym (Lib.N:MotorLayer[0]))
                                  w)
                               (GHC.Types.[] @ GHC.Show.ShowS)))))
                   Lib.Network
                   newHiddenLayer
                   newMotorLayer `cast` (Sym (Lib.N:MotorLayer[0]))) -}
65e6775c35db6f71ecc9d01a89003c76
  $wxs :: GHC.Prim.Int# -> (# Lib.Neuron, [Lib.Neuron] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
ec2d7c2f7ce855f96bb4d69f38eb5eb1
  newtype HiddenLayer = HiddenLayer [Lib.Neuron2]
da4286604bced03d08ca13e3c3563f72
  newtype MotorLayer = MotorLayer [Lib.Neuron]
6454729dbbe9bad18df56f70ee83423b
  data Network = Network Lib.HiddenLayer Lib.MotorLayer
deb5b4ea1a9c95b14b5ef489ae53e174
  data Neuron
    = Neuron {weights :: [GHC.Types.Double], age :: GHC.Types.Int}
475dec75939be41030091126e6d13919
  data Neuron2
    = Neuron2 {topDownWeights :: [GHC.Types.Double],
               bottomUpWeights :: [GHC.Types.Double],
               age2 :: GHC.Types.Int}
cf7d62c0dd75e7ab07471295610d8eb9
  type Response = [GHC.Types.Double]
5b1a51a62a0a167a031b4d504bd0330a
  newtype SensorLayer = SensorLayer [GHC.Types.Double]
baa5571c2af4f4505a01ca33a4b26023
  age :: Lib.Neuron -> GHC.Types.Int
  RecSel Left Lib.Neuron
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Neuron) ->
                 case ds of wild { Lib.Neuron ds1 ds2 -> ds2 }) -}
a9f7d3f8456afbe53956fc607674d68f
  age2 :: Lib.Neuron2 -> GHC.Types.Int
  RecSel Left Lib.Neuron2
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Neuron2) ->
                 case ds of wild { Lib.Neuron2 ds1 ds2 ds3 -> ds3 }) -}
f04ded7ff52846e910e86fcc434be157
  bottomUpWeights :: Lib.Neuron2 -> [GHC.Types.Double]
  RecSel Left Lib.Neuron2
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Neuron2) ->
                 case ds of wild { Lib.Neuron2 ds1 ds2 ds3 -> ds2 }) -}
27466d2b5d38c623aa5cd61750da804f
  bottumUpResponse :: Lib.Response -> Lib.HiddenLayer -> Lib.Response
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (x3 :: Lib.Response) (ds :: Lib.HiddenLayer) ->
                 Lib.topK
                   Lib.k
                   (GHC.Base.map
                      @ Lib.Neuron2
                      @ GHC.Types.Double
                      (\ (x4 :: Lib.Neuron2) ->
                       case Lib.$wgo
                              x3
                              (case x4 of wild { Lib.Neuron2 ds1 ds2 ds3 -> ds2 })
                              0.0## of ww { DEFAULT ->
                       GHC.Types.D# ww })
                      ds `cast` (Lib.N:HiddenLayer[0]))) -}
2825aa06b9cb650276e52db22b7360bb
  c :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 2.0##) -}
e4287da8607f32f0d998d91a13e89818
  dot :: GHC.Num.Num a => [a] -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U,A,1*U,A,A,A,1*C1(U))><S,1*U><L,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (x3 :: [a])
                   (y :: [a]) ->
                 let {
                   k1 :: a -> a -> a = GHC.Num.+ @ a $dNum
                 } in
                 let {
                   f :: a -> a -> a = GHC.Num.* @ a $dNum
                 } in
                 letrec {
                   go :: [a] -> [a] -> a -> a
                     {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
                   = \ (ds :: [a]) (_ys :: [a]) (eta :: a) ->
                     case ds of wild {
                       [] -> eta
                       : ipv ipv1
                       -> case _ys of wild1 {
                            [] -> eta : ipv2 ipv3 -> go ipv1 ipv3 (k1 eta (f ipv ipv2)) } }
                 } in
                 go x3 y (GHC.Num.fromInteger @ a $dNum Lib.dot1)) -}
f2893f6560698083faee03fc82470610
  dot1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
a121491bf02f1c9f2b349be6b28f6520
  gamma :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.D# 2000.0##) -}
a4ca69c3c5b3ac4b0a0e70a34df9c4dd
  hebbianLearn :: Lib.Neuron -> Lib.Response -> [GHC.Types.Double]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U))><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Neuron) (w1 :: Lib.Response) ->
                 case w of ww { Lib.Neuron ww1 ww2 ->
                 Lib.$whebbianLearn ww1 ww2 w1 }) -}
43e8b4db1e71f277cc957c3543687454
  hebbianLearnHidden ::
    Lib.Response
    -> Lib.Response
    -> Lib.Response
    -> Lib.HiddenLayer
    -> Lib.HiddenLayer
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,U><L,U><S,U> -}
c58d35c9d19423f8b1d0318f54245950
  hebbianLearnMotor ::
    Lib.Neuron -> Lib.Response -> [GHC.Types.Double]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U))><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Neuron) (w1 :: Lib.Response) ->
                 case w of ww { Lib.Neuron ww1 ww2 ->
                 Lib.$whebbianLearnMotor ww1 ww2 w1 }) -}
d738cfb7a6178c2211353541c824c0df
  hiddenResponse ::
    Lib.Response -> Lib.Response -> Lib.HiddenLayer -> Lib.Response
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (z :: Lib.Response)
                   (x3 :: Lib.Response)
                   (y :: Lib.HiddenLayer) ->
                 Lib.hiddenTopK
                   Lib.k
                   (GHC.List.zipWith
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      GHC.Float.plusDouble
                      (Lib.topDownResponse z y)
                      (Lib.bottumUpResponse x3 y))) -}
f90ef1dec817f9f8c4c33cbcad91ff41
  hiddenTopK ::
    GHC.Types.Int -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, Strictness: <L,1*U(U)><S,U>,
     Unfolding: (\ (k1 :: GHC.Types.Int) (ys :: [GHC.Types.Double]) ->
                 case (Lib.hiddenTopK_go ys) `cast` (Data.Monoid.N:Any[0]) of wild {
                   GHC.Types.False
                   -> GHC.Types.:
                        @ GHC.Types.Double
                        Lib.hiddenTopK2
                        (GHC.Base.map
                           @ GHC.Types.Double
                           @ GHC.Types.Double
                           Lib.hiddenTopK1
                           ys)
                   GHC.Types.True
                   -> GHC.Base.map
                        @ GHC.Types.Double
                        @ GHC.Types.Double
                        (let {
                           sorted :: [GHC.Types.Double]
                           = Data.OldList.sortBy @ GHC.Types.Double Lib.topK2 ys
                         } in
                         let {
                           min' :: GHC.Types.Double
                           = case k1 of ww { GHC.Types.I# ww1 ->
                             GHC.List.$w!! @ GHC.Types.Double sorted ww1 }
                         } in
                         \ (x3 :: GHC.Types.Double) ->
                         case x3 of wild1 { GHC.Types.D# x4 ->
                         case min' of wild2 { GHC.Types.D# y ->
                         case sorted of wild3 {
                           [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                           : x5 ds1
                           -> case x5 of wild4 { GHC.Types.D# x6 ->
                              case GHC.Prim./##
                                     (GHC.Prim.-## x4 y)
                                     (GHC.Prim.-## x6 y) of wild5 { DEFAULT ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<=## 0.0## wild5) of wild6 {
                                GHC.Types.False -> Lib.topK1
                                GHC.Types.True -> GHC.Types.D# wild5 } } } } } })
                        ys }) -}
fc666b381fded2eabaf96b9b2dc9b7d7
  hiddenTopK1 :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Types.Double) -> Lib.topK1) -}
f96455d9e1d904067e3bf843d7ea6d62
  hiddenTopK2 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0##) -}
28c58ce15cd6804912c91a13b4c7e6a6
  hiddenTopK_go :: [GHC.Types.Double] -> Data.Monoid.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e2c81ed369f17b0b65840481c6ebadee
  initialNetwork :: Lib.Network
  {- Strictness: m,
     Unfolding: (Lib.Network
                   Lib.initialNetwork2 `cast` (Sym (Lib.N:HiddenLayer[0]))
                   Lib.initialNetwork1 `cast` (Sym (Lib.N:MotorLayer[0]))) -}
22d36e87f182a32e68f433181cd0a9b3
  initialNetwork1 :: [Lib.Neuron]
  {- Unfolding: (case Lib.$wxs 4# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Lib.Neuron ww1 ww2 }) -}
582cd6caa1ec1a95e2b1d85a3e94da1d
  initialNetwork10 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.8##) -}
edfbc9cbdd064da07b19dbd25f5f6a3c
  initialNetwork11 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.4##) -}
18f248f44ec835792d0b675d80b6b2c7
  initialNetwork12 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork18
                   Lib.initialNetwork13) -}
6965b80b763c227cf92cc5ce0ca4b613
  initialNetwork13 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork17
                   Lib.initialNetwork14) -}
c4a573bd7696f42300256fc169351d7e
  initialNetwork14 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork16
                   Lib.initialNetwork15) -}
f39b212395d35151e45bb3b009d15fe1
  initialNetwork15 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork16
                   (GHC.Types.[] @ GHC.Types.Double)) -}
84feee71cc2541ea75fee1a8b65fc02e
  initialNetwork16 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.9##) -}
b0c6959acb5b284198519f57a3d2b47c
  initialNetwork17 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.6##) -}
32c2f1363763a4bb2de77754434d2ce7
  initialNetwork18 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.7##) -}
b73b2c0fd4aef67b199f2f42a77580ad
  initialNetwork19 :: Lib.Neuron2
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Neuron2
                   Lib.initialNetwork25
                   Lib.initialNetwork20
                   Lib.initialNetwork5) -}
9f0abb7b9e1de7b9dc7bfe87263a6ec3
  initialNetwork2 :: [Lib.Neuron2]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Neuron2
                   Lib.initialNetwork19
                   Lib.initialNetwork3) -}
46c7202b9f493ce18ca435935087fe8e
  initialNetwork20 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork24
                   Lib.initialNetwork21) -}
eae5761d33f92cf3a31d52782a76a907
  initialNetwork21 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork9
                   Lib.initialNetwork22) -}
54802513a7799f3059ab81dfb4912290
  initialNetwork22 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork23
                   (GHC.Types.[] @ GHC.Types.Double)) -}
2005ef0a3119017dc282b8ab59500449
  initialNetwork23 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.2##) -}
3c8e8cccaf775996955bbc46db2d5ea9
  initialNetwork24 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.5##) -}
3eb578204ff41e275ad5bd101f54f3b6
  initialNetwork25 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork29
                   Lib.initialNetwork26) -}
ee8023e8482023a60dbd161ad4830c41
  initialNetwork26 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork9
                   Lib.initialNetwork27) -}
07ac06ec5e9ee158322864d27d307d81
  initialNetwork27 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork18
                   Lib.initialNetwork28) -}
a4625243ff35cfd579feaa4dd3b9825e
  initialNetwork28 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork10
                   (GHC.Types.[] @ GHC.Types.Double)) -}
4d72baa15738640246793a09e0edefdf
  initialNetwork29 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.3##) -}
7e55a9a08cb61fa3e1969364e9194df1
  initialNetwork3 :: [Lib.Neuron2]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Neuron2
                   Lib.initialNetwork4
                   (GHC.Types.[] @ Lib.Neuron2)) -}
388848bca7aff59b0490d40f4cbdb28b
  initialNetwork4 :: Lib.Neuron2
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lib.Neuron2
                   Lib.initialNetwork12
                   Lib.initialNetwork6
                   Lib.initialNetwork5) -}
40af4bd4044c329b16a7980f9152bf6f
  initialNetwork5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
568da92778dc9b3b1cbaa6e4c2cc50e9
  initialNetwork6 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork11
                   Lib.initialNetwork7) -}
6b4ba9aa13d691ceaa9bc374f7322ce3
  initialNetwork7 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork10
                   Lib.initialNetwork8) -}
54a0f1890fc038bf2e156eaa39f43bf9
  initialNetwork8 :: [GHC.Types.Double]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Double
                   Lib.initialNetwork9
                   (GHC.Types.[] @ GHC.Types.Double)) -}
d4081a35465db22814a186890bf8d5ed
  initialNetwork9 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.1##) -}
27717400ac4ce8a89802af6853a3d7a4
  k :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
001c3bff63b2c8962504e2f0625e088d
  lRate :: Lib.Neuron2 -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)),1*U(A,A,1*U(U))>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Neuron2) ->
                 case w of ww { Lib.Neuron2 ww1 ww2 ww3 ->
                 case ww3 of ww4 { GHC.Types.I# ww5 ->
                 let {
                   x3 :: GHC.Prim.Double# = GHC.Prim.int2Double# ww5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<## x3 20.0##) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<## x3 200.0##) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim./##
                                  (GHC.Prim.+##
                                     1.0##
                                     (GHC.Prim./##
                                        (GHC.Prim.+##
                                           (GHC.Prim.-## x3 200.0##)
                                           (GHC.Prim.-## x3 200.0##))
                                        2000.0##))
                                  x3 of ww6 { DEFAULT ->
                           GHC.Types.D# ww6 }
                        GHC.Types.True
                        -> case GHC.Prim./##
                                  (GHC.Prim.+##
                                     1.0##
                                     (GHC.Prim./##
                                        (GHC.Prim.+##
                                           (GHC.Prim.-## x3 20.0##)
                                           (GHC.Prim.-## x3 20.0##))
                                        180.0##))
                                  x3 of ww6 { DEFAULT ->
                           GHC.Types.D# ww6 } }
                   GHC.Types.True
                   -> case GHC.Prim./## 1.0## x3 of ww6 { DEFAULT ->
                      GHC.Types.D# ww6 } } } }) -}
484e00365c7f343771317815a358baeb
  motorResponse :: Lib.Response -> Lib.MotorLayer -> Lib.Response
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (y :: Lib.Response) (ds :: Lib.MotorLayer) ->
                 Lib.topK
                   Lib.k
                   (GHC.Base.map
                      @ Lib.Neuron
                      @ GHC.Types.Double
                      (\ (x3 :: Lib.Neuron) ->
                       case Lib.$wgo
                              y
                              (case x3 of wild { Lib.Neuron ds1 ds2 -> ds1 })
                              0.0## of ww { DEFAULT ->
                       GHC.Types.D# ww })
                      ds `cast` (Lib.N:MotorLayer[0]))) -}
4c2c36e55d7f8e2ffc122e0e1bade791
  normalize ::
    GHC.Types.Double
    -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (min' :: GHC.Types.Double)
                   (max' :: GHC.Types.Double)
                   (x3 :: GHC.Types.Double) ->
                 case x3 of wild { GHC.Types.D# x4 ->
                 case min' of wild1 { GHC.Types.D# y ->
                 case max' of wild2 { GHC.Types.D# x5 ->
                 case GHC.Prim./##
                        (GHC.Prim.-## x4 y)
                        (GHC.Prim.-## x5 y) of wild3 { DEFAULT ->
                 GHC.Types.D# wild3 } } } }) -}
490a602150c5bf85497d5d7533efeb47
  runNetwork ::
    [[GHC.Types.Double]] -> [[GHC.Types.Double]] -> Lib.Network
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [[GHC.Types.Double]]) (w1 :: [[GHC.Types.Double]]) ->
                 case Lib.$wrunNetwork w w1 of ww { (#,#) ww1 ww2 ->
                 Lib.Network ww1 ww2 }) -}
8d70b4686bb773933c53c4537fdbabec
  runNetwork' ::
    Lib.Network -> (Lib.Response, Lib.Response) -> Lib.Network
  {- Arity: 2, Strictness: <S,1*U(U,1*U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Network) (w1 :: (Lib.Response, Lib.Response)) ->
                 case w of ww { Lib.Network ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 Lib.$wrunNetwork' ww1 ww2 ww4 ww5 } }) -}
4e7dec0f6fc68cfd66434f14189b7639
  runNetwork'1 ::
    Lib.Response -> Lib.Response -> Lib.MotorLayer -> [Lib.Neuron]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,1*U>,
     Unfolding: (\ (z :: Lib.Response)
                   (y :: Lib.Response)
                   (ds :: Lib.MotorLayer) ->
                 GHC.List.zipWith
                   @ GHC.Types.Double
                   @ Lib.Neuron
                   @ Lib.Neuron
                   (\ (z' :: GHC.Types.Double)
                      (currentNeuron :: Lib.Neuron)[OneShot] ->
                    case z' of wild { GHC.Types.D# x3 ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.>## x3 0.99##) of wild1 {
                      GHC.Types.False -> currentNeuron
                      GHC.Types.True
                      -> Lib.Neuron
                           (Lib.hebbianLearn currentNeuron y)
                           (case currentNeuron of wild2 { Lib.Neuron ds1 ds2 ->
                            case ds2 of wild3 { GHC.Types.I# x4 ->
                            GHC.Types.I# (GHC.Prim.+# x4 1#) } }) } })
                   z
                   ds `cast` (Lib.N:MotorLayer[0])) -}
e55d5c52d22861c5da2a6315c554c604
  runNetwork1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows7
                   Lib.runNetwork2) -}
1b70484d4f0e0bb45e6c583a3006621d
  runNetwork2 :: GHC.Base.String
  {- Unfolding: (GHC.Show.$fShow(,)_$sgo
                   Lib.runNetwork4
                   Lib.runNetwork3
                   (GHC.Types.[] @ GHC.Show.ShowS)) -}
3691bd013a202eb9ec437d43f251447c
  runNetwork3 :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (\ (w :: GHC.Base.String) ->
                 Lib.$w$cshowsPrec2
                   0#
                   Lib.initialNetwork1 `cast` (Sym (Lib.N:MotorLayer[0]))
                   w) -}
d6b854ae4b8e00b2c52a1c777cf1e2f1
  runNetwork4 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
146cd0faca40e9c3a3bc5d7937509c3e
  runNetwork5 :: Lib.Network
  {- Strictness: x -}
7de3c4701425aca2e07eb0c8640cd57d
  t1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 20.0##) -}
45d7edb14e8af92d470738ba49bfd743
  t2 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.D# 200.0##) -}
16cfcc3697e4e6a09fb24d52d9c7194b
  topDownResponse :: Lib.Response -> Lib.HiddenLayer -> Lib.Response
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (z :: Lib.Response) (ds :: Lib.HiddenLayer) ->
                 Lib.topK
                   Lib.k
                   (GHC.Base.map
                      @ Lib.Neuron2
                      @ GHC.Types.Double
                      (\ (x3 :: Lib.Neuron2) ->
                       case Lib.$wgo
                              z
                              (case x3 of wild { Lib.Neuron2 ds1 ds2 ds3 -> ds1 })
                              0.0## of ww { DEFAULT ->
                       GHC.Types.D# ww })
                      ds `cast` (Lib.N:HiddenLayer[0]))) -}
0be7b62f7a252c027f565187b7375f2a
  topDownWeights :: Lib.Neuron2 -> [GHC.Types.Double]
  RecSel Left Lib.Neuron2
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Neuron2) ->
                 case ds of wild { Lib.Neuron2 ds1 ds2 ds3 -> ds1 }) -}
c3aac36e99f387c3c7e6f23c0f165bcf
  topK :: GHC.Types.Int -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, Strictness: <L,1*U(U)><S,U>,
     Unfolding: (\ (k1 :: GHC.Types.Int) (xs :: [GHC.Types.Double]) ->
                 GHC.Base.map
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   (let {
                      sorted :: [GHC.Types.Double]
                      = Data.OldList.sortBy @ GHC.Types.Double Lib.topK2 xs
                    } in
                    let {
                      min' :: GHC.Types.Double
                      = case k1 of ww { GHC.Types.I# ww1 ->
                        GHC.List.$w!! @ GHC.Types.Double sorted ww1 }
                    } in
                    \ (x3 :: GHC.Types.Double) ->
                    case x3 of wild { GHC.Types.D# x4 ->
                    case min' of wild1 { GHC.Types.D# y ->
                    case sorted of wild2 {
                      [] -> case GHC.List.badHead ret_ty GHC.Types.Double of {}
                      : x5 ds1
                      -> case x5 of wild3 { GHC.Types.D# x6 ->
                         case GHC.Prim./##
                                (GHC.Prim.-## x4 y)
                                (GHC.Prim.-## x6 y) of wild4 { DEFAULT ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=## 0.0## wild4) of wild5 {
                           GHC.Types.False -> Lib.topK1
                           GHC.Types.True -> GHC.Types.D# wild4 } } } } } })
                   xs) -}
23d3b525a0cbf481a1aff6c8c2d1a726
  topK1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.0##) -}
8ab1e5a7522b89e4e822734767e84159
  topK2 :: GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (x3 :: GHC.Types.Double) (y :: GHC.Types.Double) ->
                 GHC.Classes.$fOrdDouble_$ccompare y x3) -}
c231608457e6de501c21e70da2e4bae2
  updateHiddenWeights ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> GHC.Types.Double -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U(U)>,
     Unfolding: (\ (w :: [GHC.Types.Double])
                   (sig :: [GHC.Types.Double])
                   (learningRate :: GHC.Types.Double) ->
                 GHC.List.zipWith
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   @ GHC.Types.Double
                   (\ (w1 :: GHC.Types.Double) (s :: GHC.Types.Double)[OneShot] ->
                    case learningRate of wild1 { GHC.Types.D# y ->
                    case w1 of wild2 { GHC.Types.D# y1 ->
                    case s of wild3 { GHC.Types.D# y2 ->
                    GHC.Types.D#
                      (GHC.Prim.+##
                         (GHC.Prim.*## (GHC.Prim.-## 1.0## y) y1)
                         (GHC.Prim.*## y y2)) } } })
                   w
                   sig) -}
eaafe22a5b3b80c6cce77118b4fe7408
  updateMotorWeights ::
    Lib.Response -> Lib.Response -> Lib.MotorLayer -> Lib.MotorLayer
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                Lib.runNetwork'1
                  `cast`
                (<Lib.Response>_R
                 ->_R <Lib.Response>_R
                 ->_R <Lib.MotorLayer>_R
                 ->_R Sym (Lib.N:MotorLayer[0])) -}
a040a8891135c06abbf2c7ca4379b923
  weights :: Lib.Neuron -> [GHC.Types.Double]
  RecSel Left Lib.Neuron
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lib.Neuron) ->
                 case ds of wild { Lib.Neuron ds1 ds2 -> ds1 }) -}
instance GHC.Show.Show [Lib.HiddenLayer] = Lib.$fShowHiddenLayer
instance GHC.Show.Show [Lib.MotorLayer] = Lib.$fShowMotorLayer
instance GHC.Show.Show [Lib.Network] = Lib.$fShowNetwork
instance GHC.Show.Show [Lib.Neuron] = Lib.$fShowNeuron
instance GHC.Show.Show [Lib.Neuron2] = Lib.$fShowNeuron2
instance GHC.Show.Show [Lib.SensorLayer] = Lib.$fShowSensorLayer
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

